## 1.引用计数算法：
&nbsp;&nbsp; 给对象添加一个引用计数器,每当有一个地方引用他时,计数器就加1;当引用失效时,计数器就减1,任何时刻计数器为 0 的对象就是不可能被使用的对象。
&nbsp;&nbsp;&nbsp;&nbsp; 缺点：
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比较难解决对象之间互相引用的问题。
## 2.可达性分析算法：
&nbsp;&nbsp; 在主流的商用程序语言的主流实现中，都是称通过可达性分析来判断对象是否存活的。   
&nbsp;&nbsp;&nbsp;&nbsp;  这个算法的基本思路就是通过一系列的称为 “GC Roots” 的对象作为起始点,从这些节点开始向下搜索,搜索走过的路径称为引用链,当一个对象到 “GC Roots” 没有任何引用链相连时,则证明对象是不可用的   
## 3.再谈引用：
&nbsp;&nbsp; 如果一个对象只有被引用或者没有引用的两种状态,会比较乏味,所有 JDK1.2 之后出现了下面几种类型:    
&nbsp;&nbsp;&nbsp;&nbsp;  强引用:   
&nbsp;&nbsp;&nbsp;&nbsp;  软引用:   
&nbsp;&nbsp;&nbsp;&nbsp;  弱引用:   
&nbsp;&nbsp;&nbsp;&nbsp;  虚引用:   
## 4.生存还是死亡:
&nbsp;&nbsp; 即使在可达性算法中不可达的对象,也并非必死不可,这个时候暂时处于 缓刑 期,要真正宣告对象死亡,至少经过两次标记:   
&nbsp;&nbsp;&nbsp;&nbsp; 如果对象在可达性分析后发现没有与 GC Roots 相连接的引用链,那么将会第一次被标记并进行一次筛选,筛选的条件是此对象是否有必要执行 finalize() 方法,当对象没有覆盖 finalize() 方法,或者 finalize()  方法已经被虚拟机调用过,虚拟机将这两中情况判定为 "没有必要执行" 。
&nbsp;&nbsp;&nbsp;&nbsp; 如果这个对象被判定为有表执行 finalize()  方法,那么这个对象将会防止在一个叫做 F-Queue 的队列中,并在稍后有一个虚拟机自动创建的,低优先机的 finalize 线程中去执行,这个所谓的执行时指虚拟机会触发这个方法,但是不承诺等待他运行结束,这样做的原因是,如果一个对象在 finalize（） 方法中执行缓慢,或者发生四循环,将可能导致 F-Queue 队列中的其他对象永远处于等待状态,导致整个内存回收系统瘫痪。finalize()  方法是对象逃脱死亡命运的最后一次机会,稍后 GC 将对 F-Queue 对象进行第二次小规模标记,如果对象在 finalize() 成功解救自己---只要重新和引用链上的任何一个对象关联即可。  
## 5.回收方法区:
TODO://

## 6.垃圾收集算法-- 标记--清除算法:
&nbsp;&nbsp;最基础的收集算法是 "标记--清除" 算法: 首先标记处所有需要会回收的对象,在标记完成后统一回收所有的标记对象。    
&nbsp;&nbsp;&nbsp;&nbsp;  缺点：   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1。 效率问题，标记和清除两个效率都不高 2. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片可能会导致以后程序在分大对象时无法找到足够连续的内存而不得不提前触发另一次垃圾回收动作。
![avatar](./static/标记清除算法.jpg)

## 7.垃圾收集算法-- 复制算法: 
&nbsp;&nbsp; 为了解决效率问题,出现了复制算法, 他将可用的内存分为大小相等的两块,每次只使用其中一块,当这一块的内存用完了,就将还存活的对象复制到另一个上面去,然后在把已使用的内存空间清理一次。
![avatar](./static/复制算法.jpg)

## 7.垃圾收集算法-- 标记--整理算法: 