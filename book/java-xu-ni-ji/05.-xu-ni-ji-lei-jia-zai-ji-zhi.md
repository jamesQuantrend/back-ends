# 05.虚拟机类加载机制

## 1.类加载时机：

   类从被加载到虚拟机内存中开始，到卸载出内存为止，他的整个生命周期包括：  
   加载--&gt; 验证 --&gt; 准备 --&gt; 解析 --&gt; 初始化 --&gt; 使用 --&gt; 卸载 七个阶段。  
   加载时机：  
  a. 遇到 new , getstatic , putstatic, invokestatic 这4个字节码指令时，如果类没有被初始化，则先出发触发初始化。  
  b. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有初始化，先进行初始化。  
  c. 当初始化一个类的时候，如果发现其父类还没有初始化，先初始化父类。  
  d. 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机先执行这个主类。  
  e. 当使用jdk1.7的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的结果 REF-getStatic,REF-put-Static ,REF-invokeStatic 的方法句柄，并且这个方法对应的句柄对应的类没有初始化先初始化。

## 2.加载：

   加载是指的类加载过程的一个阶段，在加载阶段，虚拟机需要完成三件事：  
   a. 通过一个类的全限定名来获取定义此类的二进制字节流。  
   b. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  
   c. 在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各个数据访问入口。  
   数组本身不通过类加载器创建，他是java虚拟机直接创建。但是数组类和类加载器有密切的关系，因为数组类的元素类型最终时靠类加载七创建的，一个数组类创建的过程就遵循以下规则：  
   a. 如果数组的组件类型是引用类型，那就递归采用加载过程加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识。  
   b. 如果数组的组件类型不是引用类型，java 虚拟机将会把数组c 标记为与类加载器关联。  
   c. 数组类的可见性和他的组件类型可以见性一致，如果组件类型不是引用类型，那数组类的可见性默认 public。  
   加在完成后，虚拟机在外部的二进制字节流按照虚拟机所需的格式存储在方法区中，方法区的数据存储格式由虚拟机实现定义，虚拟机规范未定义此区域的具体数据结构，然后在内存中实例化一个 java.lang.class 类对象，这个对象将作为程序访问方法区中这些类型数据的外部接口。

## 3.验证：

   验证时为了确保 class 文件中字节流中包含的信息符合虚拟机的要求，并且不会危害虚拟机本身的安全。  
   1.文件格式验证： 验证字节流是否符合class文件格式的规范，并且能被当前虚拟机处理。  
   2.元数据验证：对字节码描述的信息进行语义分析，保证描述的信息符合 java 语言规范。  
   3. 字节码验证：对数据流和控制流分析，确定程序的语义是合法的，符合逻辑的。    4. 符号引用验证：这个阶段的验证发生在虚拟机将符号引用转化为直接引用的时候。

## 4.准备：

   准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所只用的内存都将在方法区中进行分配。

## 5.解析：

   解析阶段是虚拟机将常量池中的符号引用替换成直接引用的过程。

## 6.初始化：

  最后一个阶段都是虚拟主导和控制的，是将实际代码中的值进行初始化。

## 7.类加载器：

   虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到java虚拟机外部去实现，方便这个应用程序自己决定如何获取所需的类，这个动作的代码模块称为“类加载器”。

## 8.类和类加载器：

   每个类都有自己的类命名空间，如果比较两个类是否相等，只有这两个类是同一个类加载器的前提下才有意义，否则，即使两个类来源与同一个 class 文件，被捅一个虚拟机加载，只要他们加载器不同，必定类不相等。

## 9.双亲委派模型：

   从 java 虚拟机的角度将，存在两种类加载器：一种是启动类加载器，这个是c++实现的，还有一种是器他的类加载器，这个是java语言实现的，独立与虚拟机外部，全部继承抽象类java.lang.classLoader。  
   从java开发角度看,类加载器分为下面几种：    a.启动类加载器：  
   b.扩展类加载器：  
   c.应用程序加载器：  
   可以自定义他们之间的关系： ![avatar](../../.gitbook/assets/shuang-qin-wei-pai-mo-xing.jpg)    如果一个类加载器收到了类加载的请求，他首先惠自己尝试加载这个类，而是把这个请求委派给父类加载器完成，每一层的类加载器都是这样，因此所有的加载请求最终都会传递到顶级的启动类加载器中，只有当父类加载器反馈无法完成加载请求时，子类才会加载。

## 10.破坏双亲委派模型：

这个是发展阶段出现的问题。

